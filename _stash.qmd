## First unit test

I'd like functions designed to automatically fill the options in drop-down. Specifically, I'd like to be able to load any dataset into the app, and each `selectInput()` would populate according to a pre-specified column 'types' (i.e., numeric, binary, categorical, etc.).

This would reduce the time spent manually entering values in the `choices` and `selected` arguments.

For example, a `pull_numeric_cols()` function would operate similar to the code below:

```{r}
#| eval: false 
#| echo: true
#| code-fold: show 
#| code-summary: 'imaginary pull_numeric_cols() function'
pull_numeric_cols(palmerpenguins::penguins)
```

```{r}
#| eval: true 
#| echo: false
#| code-fold: false 
palmerpenguins::penguins |> 
  dplyr::select(dplyr::where(is.numeric)) |> 
  colnames() |> 
  purrr::set_names()
```

In this case, I'm expecting `pull_numeric_cols()` to be passed a `data.frame` or `tibble`, identify the numeric columns (integer or double), and return a named vector of column names. 

`pull_[type]_cols()` functions would also come in handy for shiny apps with visualizations. For example, a `pull_[type]_cols()` function could be used to identify columns satisfying specific graph aesthetics or layers, such as columns with binary values (for the `color` aesthetic) or columns with a specific number of categories (for facets).



###  Binary columns (example)

Creating unit tests usually involves three steps: 1) add any data or values you will need to run the test to the top of the test â€œscopeâ€ or â€œexecution environmentâ€, 2) create the `object`, which is the output or behavior created by the test function 3) define the `expected` value, object, or behavior of the test function. 

I'll demonstrate with the `pull_binary_cols()` function:

```{r}
#| code-fold: false
#| eval: false
#| echo: true
#| code-summary: an imaginary pull_binary_cols() function
pull_binary_cols <- function(df) {
  ...
}
```


1. Create the test for `pull_binary_cols()` with `usethis::use_test("pull_binary_cols")`   
    -   I'll change the contents of `test_that()` my `pull_binary_cols()` test:

```{r}
#| code-fold: false
#| eval: false
#| echo: true
#| error: true
testthat::test_that("pull_binary_cols() works", {

})
```

### Unit test data

2. `pull_binary_cols()` needs ingest a `data.frame` or `tibble` and return the categorical columns with only two levels    
    -   I'll create a test dataset, `log_bin_df`, which I'll add to the top of the test    
    -   Then I'll apply my `pull_binary_cols()` to `log_bin_df` and assign the output to `bins`

```{r}
#| code-fold: show
#| code-summary: 'test data and apply pull_binary_cols()'
#| eval: false
#| echo: true
#| error: true
testthat::test_that("pull_binary_cols() works", {
  # test with logical data ----------------------------
  log_bin_df <- tibble::tibble(
                  bin_na = c(TRUE, FALSE, NA, TRUE),
                  bin = c(TRUE, FALSE, TRUE, FALSE),
                  chr_na = c("item:1", "item:2", "item:3", "item:1"),
                  chr = c("item:1", "item:2", "item:3", "item:4"))
    # create object
    bins <- pull_binary_cols(log_bin_df)
})
```

### Expectations

3. `bins` is the `object` created by `pull_binary_cols()`     
    -   `expected` is a named vector the two binary columns in `log_bin_df`:

```{r}
#| code-fold: show
#| code-summary: set expectations
#| eval: false
#| echo: true
#| error: true
testthat::test_that("pull_binary_cols() works", {
  # test with logical data ----------------------------
  log_bin_df <- tibble::tibble(
                    bin_na = c(TRUE, FALSE, NA, TRUE),
                    bin = c(TRUE, FALSE, TRUE, FALSE),
                    chr_na = c("item:1", "item:2", "item:3", "item:1"),
                    chr = c("item:1", "item:2", "item:3", "item:4"))
    # create object
    bins <- pull_binary_cols(log_bin_df)
    # test
    testthat::expect_equal(
      object = bins,
      expected = c(bin_na = "bin_na",
                   bin = "bin"))
})
```

This is a complete unit test for the `pull_binary_cols()` function.

### Write function 

Below is my first attempt at the `pull_binary_cols()` function:  

```{r}
#| eval: true
#| echo: true
#| code-summary: '1st attempt at pull_binary_cols()'
pull_binary_cols <- function(df) {
  # get names
  nms <- names(df)
  # set names in names
  df_nms <- purrr::set_names(nms)
  # check for binary variables
  check_binary <- function(x) {
    length(unique(x)) == 2
  }
  # get TRUE/FALSE binaries
  bin_log <- sapply(df, check_binary)
  # subset names with binaries
  df_nms[bin_log]
}
```

### Run test

Because this is my first unit test, I want to load the function (and any other changes to the package) with `devtools::load_all()`, then run the test in the console. 

This is considered 'Micro-iteration' (see [description from R packages](https://r-pkgs.org/testing-basics.html#run-tests) below): 

> **Micro-iteration:** This is the interactive phase where you initiate and refine a function and its tests in tandem. Here you will run `devtools::load_all()` often, and then execute individual expectations or whole tests interactively in the console. 

First I load, document, and install: 

::: {#fig-load-doc-install layout-ncol=1}

![Load, document, install](load-doc-install.png){#fig-load-doc-install width=70%}

Use `devtools::load_all()` to make sure any changes are included in the test.
:::

Then I run the test in the **Console**: 

::: {#fig-binary-test-fail layout-ncol=1}

![Test failure](binary-test-fail.png){#fig-binary-test-fail width=70%}

Example test failure in the **Console**
:::

### Revise function

***What happened***?

The test results tell me that `bin_na` wasn't returned from `pull_binary_cols()`. I assume it's because the missing values (`NA`) are being considered as a third category. 

-   I'll make a small change to `pull_binary_cols()` to address this:

    ```{r}
    #| eval: true
    #| echo: true
    #| code-summary: pull_binary_cols() function redo
    pull_binary_cols <- function(df) {
      log_df <- dplyr::select(tibble::as_tibble(df),
                              dplyr::where(is.logical))
      if (ncol(log_df) > 0) {
        # get names
        nms <- names(log_df)
        # set names in names
        df_nms <- purrr::set_names(nms)
        check_log_binary <- function(x) {
            all(na.omit(x) %in% TRUE:FALSE)
          }
        bins <- sapply(log_df, check_log_binary)
        return(df_nms[bins])
      }
    }
    ```
    
    -   Then I'll load, document, install, and re-run the test in the **Console**: 

    ```{verbatim}
    #| eval: false
    #| code-fold: false
    Test passed ğŸ¥‡
    ```
    
    -   And it passes!

```{r}
#| echo: false
#| results: asis
#| eval: false
co_box(color = "g", header = "TIP!", "This is a tip!")
```


## Expectation-driven development

[Test-driven development](https://www.wikiwand.com/en/Test-driven_development) recommends writing tests for your code *before* writing any code, and I'll admit, I don't adhere to this principle enough. However, I do usually write tests and functions in tandem, because `testthat` makes it easy to set (and manage) my expectations. 

Consider the simple `unit_of_work()` function again. My expectation for this function is `expected = "End result"`: 

:::: {.column-body-outset-right}
::: {#fig-expected layout-nrow=1}
![expected end result](testthat-expected.png){#fig-tests fig-align='center' width=4.0in}

`expected` is the `end result` I want to see
:::
::::


Starting with an `expected` value forces me to think through the function's '*unit(s) of work*' (and makes it easier to write).

:::: {.column-body-outset-right}

::: {#fig-object layout-nrow=1}
![unit of work](testthat-object.png){#fig-tests fig-align='center' width=4.0in}

`object` is the `unit of work` from the tested function
:::

::::

After writing my expectation and the function, I can run the test to verify the output. When/if I encounter bugs, I can use the test to help understand why and how my function failing to meet my expectations.

:::: {.callout-tip collapse='true'}

## TIP: Unit test key features 

::: {style='font-size: 1.10em; color: #696969;'}

A few key features of this unit test:   

-   It tests a *unit of work* with a *end result* 

-   The test "*contain[s] only the information required to exercise the behavior in question*" - [source](https://abseil.io/resources/swe-book/html/ch11.html)   

-   The test is isolated from the rest of the code     
  
::: {#fig-unit-test layout-ncol=1}

![unit test](unit_test.png){#fig-unit-test-1 width=4in}

Basic unit test
:::

::: 
::::

### Revising expectations

After debugging `pull_binary_cols()`, I realize I need to re-think my initial strategy. As it's currently written, `pull_binary_cols()` only testing binary *logical* variables. 
But binary variables could be:   

  -   binary integers 
      -   (`int [1:2] 0 1`)   
  -   binary characters, or   
    -   (`chr [1:2] "Yes" "No"`)  
  -   binary factors   
    -   (`Factor w/ 2 levels "Yes","No": 1 2`) or  
    -   (`Ord.factor w/ 2 levels "level 1"<"level 2": 1 2`)
    
Furthermore, I need an operational definition of a '`facet`' column. Earlier I considered facet columns as, '*categorical columns with 5 or fewer unique values*, but this should be re-written as '*character or factor columns with 5 or fewer unique values **represented in the data***'

For example, consider the two vectors below: `five_groups` and `six_groups`

```{r}
#| code-summary: function names
#| eval: true
#| code-fold: show
five_groups <- c("grp 1", "grp 2", "grp 3", 
                 "grp 4", "grp 5")
six_groups <- c("grp 1", "grp 2", "grp 3", 
                "grp 4", "grp 5", "grp 6")
```

Given the definition I'm using above, the factor below would be considered a `facet` column:

```{r}
#| code-summary: 'five unique values, five levels = facet'
#| eval: true
#| code-fold: show
str(tibble::tibble(fct5x5 = factor(x = five_groups, 
                                   levels = five_groups,
                                   labels = five_groups)))
```

What if there are six unique values, and only five `levels`/`lables`? 

```{r}
#| code-summary: 'six unique values, five levels = facet'
#| eval: true
#| code-fold: show
str(tibble::tibble(fct6x5 = factor(x = six_groups, 
                                   levels = five_groups, 
                                   labels = five_groups)))
```

This would also be a `facet` column, because it's based on the '*unique values represented in the data*'

The same is true for five unique values with six `levels`/`lables`: 

```{r}
#| code-summary: 'five unique values, six levels = facet'
#| eval: true
#| code-fold: show
str(tibble::tibble(fct6x5 = factor(x = five_groups, 
                                   levels = six_groups, 
                                   labels = six_groups)))
```


I'll need a series of utility functions to implement these rules for binary and facet columns and arrive at my `pull_[type]_cols()` goal: 

1. First I need to identify columns by `type`  
    -   i.e., logical, integer, character, factor, etc. 

2. Then detect if these columns have binary or facet values  
    -   using the definitions I've outlined above  

3. Finally, collect the categorized column names into named vectors so they can be passed to `selectInput()`
    -   specifically, to the `choices` and `selected` arguments

#### Coming up with function names 

Coming up with names for functions can be challenging (all the good names are taken!). I like to follow the [`tidyverse` style guide](https://style.tidyverse.org/syntax.html#object-names) and stick with *short verbs as a prefix* (`make_`, `get_`, `check_` etc.), and include the type of objects the function *returns* the suffix (`_df`, `_vec`, `_list`). 

I'll need to split up the work for my `pull_[type]_cols()` functions into four separate '*units of work*' and *end results*: 

1. `select_by_class()`:  
    a.    **Work**: identify columns by `type`      
    b.   **End result**: return `data.frame`/`tibble` or named vector of columns by `type`
  
2. `check_[type]_vec()`:   
    a.    **Work**: check column `type` for responses (i.e., numeric, binary, or facet)  
    b.   **End result**: return a vector of column names    
    
3. `make_[type]_vec()`:   
    a.    **Work**: iterate function #2 over the data returned by function #1   
    b.   **End result**: return a vector of column names with values by `type`  
    
4. `pull_[type]_cols`:   
    a.    **Work**: Execute #3 for each desired `pull_[type]_cols()` function  
    b.   **End result**: return a vector of all column names  
    
As a final step, I like to sketch out a pipeline if I'm developing a series of functions that are designed to work together: 

``` r
select_by_class() |> # extract columns types from data.frame/tibble
  purrr::map_vec(
    .f = make_binary_vec(check_binary_vec) # iterate binary/facet checks
         # or make_facet_vec(check_facet_vec)
    ) |> 
  pull_[type]_cols() # assemble into named vector
```

Sticking to a naming convention makes working with pipes easier, too, because I can quickly look at code I wrote six months ago and get the gist of of it's purpose.

The rough sketch above are my expectations for the  `pull_[type]_cols()` functions. Writing this made me 1) think through each function in terms of their specific "*work*", and 2) consider the returned value at each step (i.e., the "*end result*"). Some of the details might change as I start developing, but rough sketches like this reduces the amount of code I write (and then delete).

Let's start with function #1!

## Step 1: column types

Let's take a look at what the step 1 function is supposed to do:

1. `select_by_class()`:  
    a.    **Work**: identify columns by `type`      
    b.   **End result**: return `data.frame`/`tibble` or named vector of columns by `type`

My first step it to create a test file with `usethis::use_test("select_by_class")`.

After creating the test script in `tests/testthat/`, I'll want to include some test data to make sure `select_by_class()` is identifying the correct columns. 

Sometimes unit tests require specific test data. To reduce copying and pasting, I'll write a function to generate the data I need to testing and store these functions the  `helpers.R`. 

Below is `log_maker()`, an example helpers.R function for creating logical vectors:

```{r}
#| code-fold: show
#| code-summary: test data helper functions
#| eval: true
#| echo: true
#| collapse: true
log_maker <- function(size, missing = FALSE) {
  if (size <= 2 & isTRUE(missing)) {
    as.vector(c(TRUE, NA), mode = "logical")
  } else if (size <= 2 & isFALSE(missing)) {
    as.vector(c(TRUE, FALSE), mode = "logical")
  } else if (size > 2 & isTRUE(missing)) {
    rep(c(TRUE, FALSE, NA), length.out = size)
  } else if (size > 2 & isFALSE(missing)) {
    rep(c(TRUE, FALSE), length.out = size)
  }
}
log_maker(size = 4)
log_maker(size = 4, missing = TRUE)
```

:::: {.callout-tip collapse='true'}

## TIP: Test `helpers.R` 

::: {style='font-size: 1.10em; color: #696969;'}

I keep test helper functions (like `log_maker()`) in `tests/testthat/helpers.R`:

```{verbatim}
#| eval: false
#| code-fold: false
tests/testthat/
    â”œâ”€â”€ helpers.R
    â””â”€â”€ test-pull_binary_cols.R
```

`helpers.R` is loaded when I run my tests. 

::: 
::::

I can use `log_maker()` to quickly make logical columns in a `tibble()` or `data.frame()`:

```{r}
#| code-fold: true
#| code-summary: expand to view col_types_test
#| eval: true
#| echo: true
#| collapse: true
col_types_test <- tibble::tibble(
         # logical columns
         log_na = log_maker(size = 10, missing = TRUE),
         log_var = log_maker(size = 10),
         # integer columns
         int_na = int_maker(size = 10, missing = TRUE),
         int_var = int_maker(size = 10),
         # double columns
         dbl_na = dbl_maker(10, missing = TRUE),
         dbl_var = dbl_maker(size = 10),
         # character columns
         chr_na = chr_maker(size = 10, lvls = 5, missing = TRUE),
         chr_var = chr_maker(size = 10, lvls = 5,),
         # factor columns
         fct_na = fct_maker(size = 10, lvls = 5, missing = TRUE),
         fct_var = fct_maker(size = 10, lvls = 5),
         # ordered columns
         ord_na = fct_maker(size = 10, lvls = 5,
                            ord = TRUE, missing = TRUE),
         ord_fct = fct_maker(size = 10, lvls = 5, ord = TRUE))
dplyr::glimpse(col_types_test)
```

I've chosen the column names in `col_types_test` to make testing easier:

  -   Each column has a `type` prefix (`log_`, `int_`, `dbl_`, etc.)       
  -   The names indicate if they include missing values (`na`)

### Write initial test 


The *unit of work* for the first function is to identify columns by type (`select_by_class()`). 

I'll add `testthat::test_that()` to my test file and start writing a test for the `logical` columns.

1. I'll load the `col_types_test` test data and assign the output from to `col_types_test`:   

```{r}
#| code-summary: create col_type_log object
#| eval: false
#| code-fold: show
  testthat::test_that("select_by_class() logical", {
    col_types_test <- readRDS(test_path("fixtures", 
                                           "col_types_test.rds"))
  })
```
    
2. Then I'll use `expect_equal()` to test the `class()` and `names()` outputs from `select_by_class()`:
    
```{r}
#| code-summary: test class() and names()
#| eval: false
#| code-fold: show
  testthat::test_that("select_by_class() logical", {
    # data
  col_types_test <- readRDS(
                        testthat::test_path("fixtures",
                                            "col_types_test.rds"))
  # test logical class
  col_types_class <- class(select_by_class(df = col_types_test, 
                                            type = "log"))
  testthat::expect_equal(
    object = col_types_class,
    expected = c("tbl_df", "tbl", "data.frame")
  )
  # test logical names
  col_types_names <- names(select_by_class(df = col_types_test, 
                                            type = "log"))
  testthat::expect_equal(
    object = col_types_names,
    expected = c("log_na", "log_var")
  )
  })
```


The template above can be repeated for each column type. The complete test file is located [here on GitHub](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/test-select_by_class.R).

:::: {.callout-tip collapse='true'}

## TIP: Test data in `testthat/fixtures`

::: {style='font-size: 1.10em; color: #696969;'}

**Data files for testing**: store the code used to create test data in a `tests/testthat/fixtures/make_<test_data>.R` file and export it to `tests/testthat/fixtures/<test_data>.rds` with `saveRDS()`:

```{r}
#| eval: false
#| code-fold: false
# export to tests/testthat/fixtures/
# <code to create test_data>
saveRDS(test_data,
  file = "tests/testthat/fixtures/test_data.rds"
)
```

```{verbatim}
#| eval: false
#| code-fold: false
tests/testthat/
    â”œâ”€â”€ fixtures/
    â”‚   â”œâ”€â”€ test_data.rds
    â”‚   â””â”€â”€ make_test_data.R
    â”œâ”€â”€ helpers.R
    â””â”€â”€ test-unit_of_work.R

```

All data in `fixtures/` are loaded when I run `devtools::load_all()`

**Using data files for testing**: load test data files using `readRDS()` and `testthat::test_path()` in the top of your test: 

```{r}
#| eval: false
#| code-fold: false
testthat::test_that("select_by_class() logical", {
  col_types_test <- readRDS(test_path("fixtures", 
                                         "test_data.rds"))
})
```

*There's nothing special about the `fixtures/` folder name--it's just what was used in R packages.* 

**Recap:** The `helpers.R` functions are placed in `tests/testthat/helpers.R`, any code to create the test data is stored in `tests/testthat/fixtures/make_<test_data>.R`, and the output .rds file is stored in `tests/testthat/fixtures/<test_data>.rds`.


See examples of [helpers.R](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/helpers.R) and [make_test_data.R.](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/fixtures/make_col_types_test.R) You can read more about test `helpers.R` [here in R packages.](https://r-pkgs.org/testing-design.html#testthat-helper-files) 

::: 
::::

Now I'm ready to write the `select_by_class()` function. I know I'll be using `switch()` to toggle the function's purpose by the `type` argument.

I'll also add some control flow to abort if the `type` argument is invalid, and to return an empty `tibble` if no columns match the `type` (and provide and alert).

```{r}
#| code-summary: select_by_class() attempt 1
#| eval: true
#| code-fold: show
select_by_class <- function(df, type) {
  if (type %nin% c("log", "int", "chr", "fct", "list")) {
    cli::cli_abort("Invalid type argument")
  }
  df_cols <- switch(type,
    log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),
    int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),
    chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),
    fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),
    list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list)))

  if (ncol(df_cols) < 1 || nrow(df_cols) < 1 ) {
    df_cols <- structure(list(),
                         class = c("tbl_df", "tbl", "data.frame"),
                         row.names = integer(0),
                         names = character(0))
    return(df_cols)
    cli::cli_alert_info("No columns of that type...")
  } else {
    return(df_cols)
  }

}
```


I'll remove the info alert when `select_by_class()` passes all it's tests--but it helps me in the development process (see how it works below):
  
```{r}
#| eval: true
#| code-fold: false
odd_cols <- tibble::tibble(
                    array_col = array(data = c('a', 'b', 'c'), 
                                             dim = c(2,4)))
select_column_class(odd_cols, type = "int")
```

```{verbatim}
#| eval: false
#| code-fold: false
â„¹ No columns of that type...
# A tibble: 0 Ã— 0
```

### Run test file

At this point, I have quite a few tests in `test-select_by_class.R`, but they all have the same basic structure. I want to run all of them at once and debug as-needed. 
This is referred to as 'Mezzo-iteration', 

> [**Mezzo-iteration:**](https://r-pkgs.org/testing-basics.html#run-tests) As one fileâ€™s-worth of functions and their associated tests start to shape up, you will want to execute the entire file of associated tests, perhaps with `testthat::test_file()`:


``` r
testthat::test_file(path = "tests/testthat/test-select_by_class.R")
```

```{verbatim}
#| eval: false
#| code-fold: false
[ FAIL 1 | WARN 0 | SKIP 0 | PASS 5 ]

â”€â”€ Error (test-select_by_class.R:52:5): select_by_class() works â”€â”€â”€â”€â”€
Error in `select_by_class(col_types_test, type = "dbl")`: Invalid type argument
Backtrace:
 1. select_by_class(col_types_test, type = "dbl")
      at test-select_by_class.R:52:4

[ FAIL 1 | WARN 0 | SKIP 0 | PASS 5 ]
```

I have a test failure on the `double` columns. Can you see it? I forgot to add `"dbl"` to the `switch()` function *and* control flow at the top of `select_by_class()`. I'll rewrite `select_by_class()` below, load, document, install and rebuild the package, then run the test again. 

```{r}
#| eval: true
#| code-fold: show
#| code-summary: select_by_class() attempt 2
select_by_class <- function(df, type) {

  if (type %nin% c("log", "int", "dbl", "chr", "fct", "list")) {
    cli::cli_abort("No columns of that type...")
  }

  df_cols <- switch(type,
    log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),
    int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),
    dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),
    chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),
    fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),
    list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list)))

  if (ncol(df_cols) < 1 || nrow(df_cols) < 1 ) {
    df_cols <- structure(list(),
                         class = c("tbl_df", "tbl", "data.frame"),
                         row.names = integer(0),
                         names = character(0))
    return(df_cols)
    cli::cli_alert_info("No columns of that type...")
  } else {
    return(df_cols)
  }

}
```

```{r}
#| eval: false
#| code-fold: false 
devtools::load_all()
```

```{verbatim}
#| eval: false
#| code-fold: false 
â„¹ Loading utap
```

```{r}
#| eval: false
#| code-fold: false 
devtools::document()
```

```{verbatim}
#| eval: false
#| code-fold: false  
â„¹ Updating utap documentation
â„¹ Loading utap
```

```{verbatim}
#| eval: false
#| code-fold: false 
Restarting R session...

* Project '~/projects/apps/utap' loaded. [renv 0.17.3]
library(utap)
```

Re-run test file:

``` r
testthat::test_file(path = "tests/testthat/test-select_by_class.R")
```

```{verbatim}
#| eval: false
#| code-fold: show 
#| code-summary: test results
[ FAIL 0 | WARN 0 | SKIP 0 | PASS 10 ]
```

Great--but I have no way knowing if my error will reliably trigger, so I should include that specific behavior in a test!

### Testing for errors

It's a good idea to include tests for any breaking error messages in your functions. I want to make sure my error message is informative (and gives a hint of what I can pass to the `type` argument).

```{r}
#| eval: true
#| code-fold: show
#| code-summary: improved error message
select_by_class <- function(df, type) {

  if (type %nin% c("log", "int", "dbl", "chr", "fct", "list")) {
    cli::cli_abort("Invalid `type` argument. Must be one of:\n
          'log', 'int', 'dbl', 'chr', 'fct', 'list'")
  }

  df_cols <- switch(type,
    log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),
    int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),
    dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),
    chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),
    fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),
    list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list)))

  if (ncol(df_cols) < 1 || nrow(df_cols) < 1 ) {
    cli::cli_alert_info(glue::glue("No {type} columns"))
    df_cols <- structure(list(),
                         class = c("tbl_df", "tbl", "data.frame"),
                         row.names = integer(0),
                         names = character(0))
    return(df_cols)
  } else {
    return(df_cols)
  }

}
```

```{r}
#| eval: true
#| code-fold: false 
#| error: true
select_by_class(odd_cols, type = "array")
```

The test for this error uses `testthat::expect_error()`, and the `object` is the `select_by_class()` with an invalid `type` argument. 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: type error test
  # test error type
  testthat::test_that("select_by_class() type error", {    t
    col_types_test <- readRDS(test_path("fixtures",
                                          "col_types_test.rds"))
    # test type error
    testthat::expect_error(
      object = select_by_class(col_types_test, type = "array")
    )
  })
```

I can add this test in the `test-select_by_class.R` file (it's fine to have multiple tests in the same test file).

As a final step, I'll rename the `select_by_class()` to `select_column_class()`:

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: select_column_class()
# select_column_class ----
select_column_class <- function(df, type) {
  if (type %nin% c("log", "int", "dbl", "chr", "fct", "list")) {
    cli::cli_abort("Invalid `type` argument. Must be one of:\n
          'log', 'int', 'dbl', 'chr', 'fct', 'list'")
  }
  df_cols <- switch(type,
    log = dplyr::select(tibble::as_tibble(df), dplyr::where(is.logical)),
    int = dplyr::select(tibble::as_tibble(df), dplyr::where(is.integer)),
    dbl = dplyr::select(tibble::as_tibble(df), dplyr::where(is.double)),
    chr = dplyr::select(tibble::as_tibble(df), dplyr::where(is.character)),
    fct = dplyr::select(tibble::as_tibble(df), dplyr::where(is.factor)),
    list = dplyr::select(tibble::as_tibble(df), dplyr::where(is.list)))

  if (ncol(df_cols) < 1 || nrow(df_cols) < 1 ) {
    cli::cli_alert_info(glue::glue("No {type} columns"))
    df_cols <- structure(list(),
                         class = c("tbl_df", "tbl", "data.frame"),
                         row.names = integer(0),
                         names = character(0))
    return(df_cols)
  } else {
    return(df_cols)
  }
}
```

Then I'll wrap `select_column_class()` with `select_by_class()` and add a `return_tbl` argument to toggle between return objects (`tibble` or a named vector).

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: select_by_class()
# select_by_class ----
select_by_class <- function(df, type, return_tbl = TRUE) {
  if (isFALSE(return_tbl)) {
    col_types_df <- select_column_class(df, type = type)
    nms <- names(col_types_df)
    col_types <- purrr::set_names(nms)
  } else {
    col_types <- select_column_class(df, type = type)
  }
  return(col_types)
}
```

This aligns more closely with my naming convention (and doesn't require re-writing any previous tests!)

In my test file, I'll use `purrr::set_names()` to change the `expected` return value with these new expectations. An example test for the logical columns is below:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: expect logical columns (as vector)
# select_column_class
# test logical names
testthat::expect_equal(
  object = select_by_class(df = col_types_test,
                         type = "log",
                         return_tbl = FALSE),
  expected = purrr::set_names(c("log_na", "log_var"))
)
```

*View the full test file [here](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/test-select_by_class.R)*

### Step 1 test results  

When I started adding tests to the `test-select_by_class.R` file, I ran the tests using `testthat::test_file()`. As I get closer to a semi-final draft of the function, I switch to `devtools::test()` (which runs all the tests in the `tests/testthat/` folder):

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: run all tests
devtools::test()
```

This is referred to as 'Macro-iteration', 


> [**Macro-iteration:**](https://r-pkgs.org/testing-basics.html#run-tests) As you near the completion of a new feature or bug fix, you will want to run the entire test suite.

```{verbatim}
#| eval: false
#| code-fold: show 
#| code-summary: test results
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols
âœ” |        16 | select_by_class [0.2s]

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 0.3 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 17 ]

OLE - cool code.
```

And see they all pass!

```{r}
#| echo: false
#| results: asis
#| eval: false
co_box(color = "g", header = "TIP!", "This is a tip!")
```

:::: {.callout-tip collapse='false'}

## TIP: Unit test key features 

::: {style='font-size: 1.10em; color: #696969;'}

A few key features of using unit tests with data:  

  -   Create/use the smallest dataset possible to test expectations  
  -   Store test files in `tests/testthhat/<dir>`, load with `test_path()` - [source](https://r-pkgs.org/testing-design.html#storing-test-data)
  -   Keep test isolated (*in `testthat/`*) from the rest of the code  

::: {#fig-unit-test layout-ncol=1}

![unit tests with data](unit_test_dep_data.png){#fig-unit-test-1 width=55%}

Unit test with data
:::

::: 
::::



## Step 2: check vector types

Function #2 is expected to perform the following: 

2. **Work**: check column `type` for responses (binary or facet)  
    a.   **End result**: return a vector of column names 

I'll follow the naming conventions I described above for these functions and call them, `check_binary_vec()` and `check_facet_vec()`.

### Check binary columns

The `check_binary_vec()` function will check each column type (i.e., numeric, binary, or facet) returned from `select_by_class()`, and return a vector of column names. 

An example test for this function is below. *Note that `check_binary_vec()` and `check_facet_vec()` ingest vectors and return vectors*:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: check_binary_vec() tests
test_that("check_binary_vec logical works", {
  # test logical (missing)
  expect_equal(object = check_binary_vec(
                      x = log_maker(size = 2, missing = TRUE),
                      type = "log"),
               expected = TRUE)
  # test logical 
  expect_equal(object = check_binary_vec(
                      x = log_maker(size = 2),
                      type = "log"),
               expected = TRUE)
  # test all FALSE (with missing)
  expect_equal(
    object = check_binary_vec(x = c(FALSE, FALSE, NA), type = "log"),
    expected = TRUE)
  # test all FALSE (no missing)
  expect_equal(
    object = check_binary_vec(x = c(FALSE, FALSE), type = "log"),
    expected = TRUE)
})
```

*View the entire test script [here.](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/test-check_binary_vec.R)*

### Check facet columns 

The facet column tests are similar, but these have fewer expectations  than the binary variables, because they only including character and factor columns (the character column checks are below): 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: check_facet_vec() tests
test_that("check_facet_vec() character", {
    # ---- FACET VARIABLES ----
    # test character (5 unique values)
    chr_test <- check_facet_vec(x =
                  chr_maker(size = 10, lvls = 5),
                            type = "chr")
    expect_equal(object = chr_test,
                 expected = TRUE)
    # test character (5 unique values, missing)
    chr_test <- check_facet_vec(x =
                  chr_maker(size = 10, lvls = 5,
                            missing = TRUE),
                            type = "chr")
    expect_equal(object = chr_test,
                 expected = TRUE)
    # ---- NOT FACET VARIABLES ----
    # test character (6 unique values)
    chr_test <- check_facet_vec(x =
                  chr_maker(size = 10, lvls = 6),
                            type = "chr")
    expect_equal(object = chr_test,
                 expected = FALSE)
    # test character (6 unique values, missing)
    chr_test <- check_facet_vec(x =
                  chr_maker(size = 10, lvls = 6,
                            missing = TRUE),
                            type = "chr")
    expect_equal(object = chr_test,
                 expected = FALSE)
})
```

I'll also include the [edge cases](https://www.wikiwand.com/en/Edge_case) I discussed above:

-   A five-level factor, but six unique and missing values represented in the data:

    ```{r}
    #| eval: false
    #| code-fold: show 
    #| code-summary: 'factor edge case 1'
    # test factor (5 levels, 6 represented, with missing = 5 unique)
    test_facet <- check_facet_vec(x =
                factor(c("group 1", "group 2", "group 3", NA_character_,
                         "group 4", "group 5", "group 6"),
                  levels = c("group 1", "group 2", "group 3",
                             "group 4", "group 5")),
                  type = "fct")
    expect_equal(object = test_facet,
                 expected = TRUE)
    ```
    
    -   Or a six-level factor with five unique and missing values represented in the data:
    
    ```{r}
    #| eval: false
    #| code-fold: show 
    #| code-summary: 'factor edge case 2'
    # test factor (6 levels, 5 represented, with missing = 5 unique)
    test_facet <- check_facet_vec(x =
                factor(c("group 1", "group 2", "group 3", NA_character_,
                         "group 4", "group 5"),
                  levels = c("group 1", "group 2", "group 3",
                             "group 4", "group 5", "group 6")),
                    type = "fct")
    expect_equal(object = test_facet,
                 expected = TRUE)
    ```
    

The tests for `check_binary_vec()` and `check_facet_vec()` are a little tedious to write, but these are the 'nuts and bolts' of the `pull_[type]_cols()` functions, so I want to confirm I'm getting the correct values.

*I also included the tests for ordinal factors, which you can view in the full test file [here.](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/test-check_facet_vec.R)*

### Write binary function

First I'll write a function for the logical vectors: 

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: check_log_binary
check_log_binary <- function(x) {
  all(na.omit(x) %in% TRUE:FALSE) 
}
check_log_binary(c(TRUE, FALSE, NA))
```

Great--now I can write `check_` functions for integers, characters, and factors:

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: binary checks
check_int_binary <- function(x) {
  all(na.omit(x) %in% 0:1) 
}
check_chr_binary <- function(x) {
  length(unique(na.omit(x))) == 2 
}
check_fct_binary <- function(x) {
  length(levels(na.omit(x))) == 2 
}
```

The final step is to wrap each of these in a function and build a `switch()` for the `type` argument: 

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: check_binary_vec()
check_binary_vec <- function(x, type) {
    check_log_binary <- function(x) { all(na.omit(x) %in% TRUE:FALSE) }
    check_int_binary <- function(x) { all(na.omit(x) %in% 0:1) }
    check_chr_binary <- function(x) { length(unique(na.omit(x))) == 2 }
    check_fct_binary <- function(x) { length(levels(na.omit(x))) == 2 }
  switch(type,
    log = check_log_binary(x),
    int = check_int_binary(x),
    chr = check_chr_binary(x),
    fct = check_fct_binary(x))
}
```

### Write facet function

The facet checks look very similar to the binary checks, but without the functions for logical and integer vectors. 

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: check_facet_vec()
check_facet_vec <- function(x, type) {
      check_chr_facet <- function(x) { length(unique(na.omit(x))) <= 5 }
      check_fct_facet <- function(x) { length(unique(na.omit(x))) <= 5 }
        switch(type,
            chr = check_chr_facet(x),
            ord = check_fct_facet(x),
            fct = check_fct_facet(x))
}
```

#### Step 2 test results 

I'll run all the tests up to this point with `devtools::test()` 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: run step 1 and step 2 tests
devtools::test()
```

```{verbatim}
#| eval: false
#| code-fold: show 
#| code-summary: step 2 tests results
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols      
âœ” |        25 | check_binary_vec [0.2s]
âœ” |        16 | check_facet_vec     
âœ” |        16 | select_by_class [0.2s]

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 0.5 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 58 ]
```

I'm getting quite a few passing tests--let's move onto step number 3! 

## Step 3: map(#2, #1)

Let's recap what steps #1 and #2 are doing: 

1. `select_by_class()`: ingest a `data.frame`/`tibble` and return colunms by type (as `tibble` or named vector)

    ``` r
    select_by_class(df = <data>, 
                  type = <type>, 
                  return_tbl = TRUE)
    ```

2. `check_binary_vec()`/`check_facet_vec()`: check the columns passed from `select_by_class()` for binary or facet variables: 

    ``` r
    check_binary/facet_vec(x = <vector>, 
                           type = <type>)
    ```
    
The input argument in step 2 is a vector (`x`), so I'll need to iterate the `check_binary_vec()`/`check_facet_vec()` over the returned `data.frame` or `tibble`.

Once again, having some `_maker()` functions in my tests `helpers.R` file will save me a ton of time here. 

I've created a [`bin_maker()` function](https://github.com/mjfrigaard/utap/blob/cf97049cb4ab5378d2d7a3b3e3f3973061c8b2d7/tests/testthat/helpers.R#L135) that quickly creates binary variables (with and without missing values):

```{r}
#| eval: true
#| code-fold: show 
#| collapse: true
#| code-summary: bin_maker()
bin_maker(type = "log", size = 5, missing = FALSE)
bin_maker(type = "ord", size = 5, missing = TRUE)
```

I'll use `bin_maker()` to create the test data for the `binary_vec_test()` expectations: 
    
```{r}
#| eval: false
#| code-fold: true 
#| code-summary: expand to view binary_vec_test
#| collapse: true
binary_vec_test <- tibble::tibble(
  bin_maker(type = "log", size = 10, missing = FALSE),
  bin_maker(type = "log", size = 10, missing = TRUE),
  bin_maker(type = "int", size = 10, missing = FALSE),
  bin_maker(type = "int", size = 10, missing = TRUE),
  bin_maker(type = "chr", size = 10, missing = FALSE),
  bin_maker(type = "chr", size = 10, missing = TRUE),
  bin_maker(type = "fct", size = 10, missing = FALSE),
  bin_maker(type = "fct", size = 10, missing = TRUE),
  bin_maker(type = "ord", size = 10, missing = FALSE),
  bin_maker(type = "ord", size = 10, missing = TRUE)
) |>
  purrr::set_names(c(
    "log", "log_na", "int", "int_na", "chr",
    "chr_na", "fct", "fct_na", "ord", "ord_na"
  ))
# export to tests/testthat/fixtures/
saveRDS(binary_vec_test,
  file = "tests/testthat/fixtures/binary_vec_test.rds"
)
```

`binary_vec_test` is created with [`tests/testthat/fixtures/make_binary_vec_test.R` file](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/fixtures/make_binary_vec_test.R) and loaded it at the top of each test with `readRDS()` and `testthat::test_path("fixtures", "binary_vec_test.rds")`:

### Binary vector tests 

Below is an example `make_binary_vec()` test for the logical columns in the `binary_vec_test` test data:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: make_binary_vec() logical tests
test_that("make_binary_vec() logical works", {
  binary_vec_test <- readRDS(
                        testthat::test_path("fixtures",
                                      "binary_vec_test.rds"))
  # test logical
  expect_equal(object = select(binary_vec_test, 
                                    where(is.logical)) |>
                        make_binary_vec(type = "log"),
               expected = purrr::set_names(c("log", "log_na")))
})
```

I could've use the `select_by_class()` function to collect the logical columns for `make_binary_vec()`, but if the test failed, it would be harder to debug (and tests for that function belong in their own separate file).

You can view the full set of tests [here.](https://github.com/mjfrigaard/utap/blob/main/tests/testthat/test-make_binary_vec.R)

### Write `make_binary` function 

`make_binary_vec()` requires a few control flow considerations:    
    1) if the `df` has zero columns, it should return an empty named vector, and   
    2) it should return an empty named vector if no columns match the `type` argument  
    
```{r}
#| eval: true
#| code-fold: show 
#| code-summary: make_binary_vec()
make_binary_vec <- function(df, type) {
  # consideration #1
  if (ncol(df) < 1) {
    cli::cli_alert_info(glue::glue("No {type} binary columns!"))
    return(purrr::set_names(vector(mode = "character")))
  } else {
    nms <- names(df)
    dm_nms <- purrr::set_names(nms)
    bin_set <- purrr::map_vec(
                    .x = df,
                    .f = check_binary_vec,
                    type = type)
    # consideration #2
    if (sum(bin_set) < 1) {
      cli::cli_alert_info(glue::glue("No {type} binary values!"))
      bins <- purrr::set_names(vector(mode = "character"))
    } else {
      cli::cli_alert_success(glue::glue("{type} binary values!"))
      bins <- purrr::set_names(dm_nms[bin_set])
    }
  }
  return(bins)
}
```

The first consideration is protecting me from the `select_by_class()` function returning an empty `tibble`. The second consideration is protecting me from the `df` having zero columns match the `type` argument.

#### Using messages 

While I'm developing `make_binary_vec()`, I'll use the `cli::cli_alert_success()` and `glue::glue()` functions to let me know which behavior `make_binary_vec()` is performing: 

-   If the `df` returned from `select_by_class()` has zero columns:
  
    ```{r}
    #| eval: false
    #| code-fold: show
    #| code-summary: df cli alert no columns!
    make_binary_vec(df = 
        structure(list(), 
          class = c("tbl_df", "tbl", "data.frame"), 
          row.names = c(NA, -0L)),
        type = "fct")
    ```
    
    ```{verbatim}
    #| eval: false
    #| code-fold: false 
    â„¹ No fct binary columns!
    named character(0)
    ```
    
    -   If no columns are matched with the `type` argument:

    ```{r}
    #| eval: false
    #| code-fold: show 
    #| code-summary: check_binary_vec() cli alert no columns!
    make_binary_vec(
      tibble::tibble(
        bin_log = bin_maker(type = "log", 
                            size = 10),
        bin_log_na = bin_maker(type = "log", 
                               size = 10,
                               missing = TRUE)), 
      type = "fct")
    ```
    
    ```{verbatim}
    #| eval: false
    #| code-fold: false 
    â„¹ No fct binary values!
    named character(0)
    ```

    -   If at least one column is matched with the `type` argument:

    ```{r}
    #| eval: false
    #| code-fold: show 
    #| code-summary: check_binary_vec() cli alert columns!
    make_binary_vec(
      tibble::tibble(
        bin_log = bin_maker(type = "log", 
                            size = 10),
        bin_log_na = bin_maker(type = "log", 
                               size = 10,
                               missing = TRUE)), 
      type = "log")
    ```
    
    ```{verbatim}
    #| eval: false
    #| code-fold: false 
    âœ” log binary values!
         bin_log   bin_log_na 
       "bin_log" "bin_log_na"
    ```
  

I'll remove the `cli` messages when I'm ready to run the tests.

### Step 3 binary test results 

The results from `devtools::test()` are below. 

```{verbatim}
#| eval: false
#| code-fold: false 
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols          
âœ” |        25 | check_binary_vec [0.2s]    
âœ” |        16 | check_facet_vec [0.1s]     
âœ” |        16 | select_by_class [0.2s]       
âœ” |         5 | make_binary_vec            

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 0.7 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 63 ]
```


### Facet vector tests 

Similar to the `make_binary_vec()` tests, I've created a [`facet_maker()`](https://github.com/mjfrigaard/utap/blob/cf97049cb4ab5378d2d7a3b3e3f3973061c8b2d7/tests/testthat/helpers.R#L187) function to help create facet test data. 

```{r}
#| eval: true
#| code-fold: show 
#| code-summary: facet_maker() helper
facet_maker(
  type = "ord", # type of variable
  size = 5, # length of vector
  lvls = 3, # levels
  missing = FALSE) # include missing?
```

I'll create test data for the `facet_maker()` tests, `facet_vec_test`, and store it in the `tests/testthat/fixtures/make_facet_vec_test.R` file:

```{r}
#| eval: true
#| code-fold: true 
#| code-summary: expand to view facet_vec_test data
#| collapse: true
facet_vec_test <- tibble::tibble(
  # character facets
  facet_maker(type = "chr", size = 10, lvls = 5, missing = FALSE),
  facet_maker(type = "chr", size = 10, lvls = 5, missing = TRUE),
  facet_maker(type = "chr", size = 10, lvls = 6, missing = FALSE),
  facet_maker(type = "chr", size = 10, lvls = 6, missing = TRUE),
  # factor facets
  facet_maker(type = "fct", size = 10, lvls = 5, missing = FALSE),
  facet_maker(type = "fct", size = 10, lvls = 5, missing = TRUE),
  facet_maker(type = "fct", size = 10, lvls = 6, missing = FALSE),
  facet_maker(type = "fct", size = 10, lvls = 6, missing = TRUE),
  # ordered facets
  facet_maker(type = "ord", size = 10, lvls = 5, missing = FALSE),
  facet_maker(type = "ord", size = 10, lvls = 5, missing = TRUE),
  facet_maker(type = "ord", size = 10, lvls = 6, missing = FALSE),
  facet_maker(type = "ord", size = 10, lvls = 6, missing = TRUE)) |>
  purrr::set_names(c("chr5", "chr5_na", "chr6", "chr6_na",
                     "fct5", "fct5_na", "fct6", "fct6_na",
                     "ord5", "ord5_na", "ord6", "ord6_na"))
dplyr::glimpse(facet_vec_test)
```

The `facet_vec_test` data has columns that should be included *and* exluded as facets. 

The `facet_vec_test` data are loaded at the top of the test file, then `dplyr` is used to `select` the columns by `type` before being passed to `make_facet_vec()` 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: make_facet_vec() facets test
test_that("make_facet_vec() facets work", {
  facet_vec_test <- readRDS(
                      testthat::test_path("fixtures",
                                          "facet_vec_test.rds"))
  # test character
  expect_equal(object = dplyr::select(facet_vec_test,
                                dplyr::where(is.character)) |>
                        make_facet_vec(type = "chr"),
               expected = purrr::set_names(
                 c(chr5 = "chr5", chr5_na = "chr5_na")
                 ))
})
```

The columns that should *not* be classified as facets are also included in this test: 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: make_facet_vec() non-facets test
test_that("make_facet_vec() non-facets work", {
  facet_vec_test <- readRDS(
                      testthat::test_path("fixtures",
                                          "facet_vec_test.rds"))
  # test character (failures)
  expect_equal(object = dplyr::select(facet_vec_test,
                              dplyr::all_of(c("chr6", "chr6_na"))) |>
                        make_facet_vec(type = "chr"),
               expected = structure(character(0), 
                                    names = character(0)))
})
```

### Write `make_facet` function 

The `make_facet_vec()` function is similar to the `make_binary_vec()` function, but includes the `check_facet_vec()` in `purrr::map_vec()` step (and different `cli::cli_alert_info()`/`cli::cli_alert_success()` messages):

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: make_facet_checks_df()
make_facet_vec <- function(df, type) {
  if (ncol(df) < 1) {
    cli::cli_alert_info(glue::glue("No {type} facet columns!"))
    return(purrr::set_names(vector(mode = "character")))
  } else {
    nms <- names(df)
    # set names in names
    dm_nms <- purrr::set_names(nms)
    facet_set <- purrr::map_vec(
                      .x = df,
                      .f = check_facet_vec,
                      type = type)
    if (sum(facet_set) < 1) {
      cli::cli_alert_info(glue::glue("No {type} facet values!"))
      facets <- purrr::set_names(vector(mode = "character"))
    } else {
      cli::cli_alert_success(glue::glue("{type} facet values!"))
      facets <- purrr::set_names(dm_nms[facet_set])
    }
  }
  return(facets)
}
```

### Step 3 facet test results 

I'll run the complete set of tests in the `tests/testthat/` folder with `devtools::test()`: 

```{r}
#| eval: false
#| code-fold: false 
devtools::test()
```

I've reorganized the output to list the tests chronologically.

```{verbatim}
#| eval: false
#| code-fold: false 
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols
âœ” |        16 | select_by_class [0.2s]
âœ” |        25 | check_binary_vec [0.2s]
âœ” |        16 | check_facet_vec
âœ” |         5 | make_binary_vec
âœ” |         7 | make_facet_vec

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 0.7 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 70 ]
```

Almost there!
  
## Step 4: Step #1 |> Step #3

In the final step for the `pull_[type]_cols()` functions, I want to pipe the output from step 1 into the functions in step 3. 

### Create test data

I'll want another test dataset for these functions, which I will store in `tests/testthat/fixtures/make_pull_cols_test.R` and load with `readRDS()` and `testthat::test_path()`

```{r}
#| eval: true
#| code-fold: true 
#| code-summary: expand to see pull_cols_test
#| collapse: true
pull_cols_test <- tibble::tibble(
     # logical binary
     log_bin_na = bin_maker(type = "log",
                            size = 10, missing = TRUE),
     log_bin = bin_maker(type = "log",
                         size = 10, missing = FALSE),
  
     # integer binary
     int_bin_na = bin_maker(type = "int",
                            size = 10, missing = TRUE),
     int_bin = bin_maker(type = "int",
                         size = 10, missing = FALSE),
  
     # character binary
     chr_bin_na = bin_maker(type = "chr",
                            size = 10, missing = TRUE),
     chr_bin = bin_maker(type = "chr",
                         size = 10, missing = FALSE),
     chr_bin2_na = chr_maker(size = 10, 
                         lvls = 1, missing = TRUE),
  
     # double
     dbl_var_na = dbl_maker(10, missing = TRUE),
     dbl_var = dbl_maker(size = 10),
     # integer
     int_var_na = int_maker(10, missing = TRUE),
     int_var = int_maker(size = 10),
     # character
     chr6_var = chr_maker(size = 10, 
                          lvls = 6, missing = TRUE),
     chr7_var_na = chr_maker(size = 10, lvls = 7),
      # factor
     fct6_var_na = fct_maker(size = 10, 
                             lvls = 6, missing = TRUE),
     fct7_var = fct_maker(size = 10, lvls = 7),
     # ordered
     ord6_var_na = fct_maker(size = 10, lvls = 6, 
                             ord = TRUE, missing = TRUE),
     ord7_var = fct_maker(size = 10, 
                          lvls = 7, ord = TRUE),
     
     # character facets
     chr_facet5 = facet_maker(type = "chr", size = 10,
                              lvls = 5, missing = FALSE),
     chr_facet5_na = facet_maker(type = "chr", size = 10,
                              lvls = 5, missing = TRUE),
     # factor facets
     fct_facet5 = facet_maker(type = "fct", size = 10,
                              lvls = 5, missing = FALSE),
     fct_facet5_na = facet_maker(type = "fct", size = 10,
                              lvls = 5, missing = TRUE),
     # ordered facets
     ord_facet5 = facet_maker(type = "ord", size = 10,
                              lvls = 5, missing = FALSE),
     ord_facet5_na = facet_maker(type = "ord", size = 10,
                              lvls = 5, missing = TRUE))
dplyr::glimpse(pull_cols_test)
```

### Write binary columns test

I already have a test file created for the `pull_binary_cols()` function, so I'll delete the existing test and replace it with the tests for binary variables. 

My expectation is that I'll be able to pass `pull_cols_test` to `pull_binary_cols()` and it will return a named vector of binary columns. 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_binary_cols() test
testthat::test_that("pull_binary_cols() works", {
  pull_cols_test <- readRDS(
                        testthat::test_path("fixtures",
                                    "pull_cols_test.rds"))
  testthat::expect_equal(
    object = pull_binary_cols(pull_cols_test),
    expected =
      c(log_bin_na = "log_bin_na",
        log_bin = "log_bin",
        int_bin_na = "int_bin_na",
        int_bin = "int_bin",
        chr_bin_na = "chr_bin_na",
        chr_bin = "chr_bin")
    )
})
```

### Write pull_binary_cols()

If I've created steps 1-3 correctly, the `pull_binary_cols()` function *should* be somewhat straightforward:
    
```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_binary_cols()
pull_binary_cols <- function(df) {
  # logical
  log_bins <- select_by_class(df, "log") |> make_binary_vec("log")
  # integer
  int_bins <- select_by_class(df, "int") |> make_binary_vec("int")
  # character
  chr_bins <- select_by_class(df, "chr") |> make_binary_vec("chr")
  # factors
  fct_bins <- select_by_class(df, "fct") |> make_binary_vec("fct")
  # assemble
  all_bins <- list(log_bins, int_bins, chr_bins, fct_bins)
  # reduce
  bins_list <- purrr::compact(all_bins)
  # vector
  bins <- purrr::list_c(bins_list)
  return(bins)
}
```

`purrr::compact()` will remove the empty (`NULL`) items in `all_bins`, and `purrr::list_c()` will convert the list to a named vector. 

### Write facet columns test

My expectation for `pull_facet_cols()` is that it will return a named vector of facet columns from `pull_cols_test` (after I've removed the binary columns).

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_facet_cols() test
testthat::test_that("pull_facet_cols() works", {

  pull_cols_test <- readRDS(testthat::test_path("fixtures", "pull_cols_test.rds"))
  # remove binary columns
  testthat::expect_equal(
    object = dplyr::select(pull_cols_test,
                    !dplyr::contains("bin")) |> 
                                  pull_facet_cols(),
    expected =
      c(chr_facet5 = "chr_facet5",
        chr_facet5_na = "chr_facet5_na",
        fct_facet5 = "fct_facet5",
        fct_facet5_na = "fct_facet5_na",
        ord_facet5 = "ord_facet5",
        ord_facet5_na = "ord_facet5_na")
    )
})
```

### Write pull_facet_cols()

`pull_facet_cols()` is similar to (but shorter than) `pull_binary_cols()`:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_facet_cols()
pull_facet_cols <- function(df) {
  # character
  chr_facets <- select_by_class(df, "chr") |> make_facet_vec("chr")
  # factors
  fct_facets <- select_by_class(df, "fct") |> make_facet_vec("fct")
  # assemble
  all_facets <- list(chr_facets, fct_facets)
  # reduce
  facets_list <- purrr::compact(all_facets)
  # vector
  facets <- purrr::list_c(facets_list)
  return(facets)
}
```

### Run binary/facet columns tests

I'll run these tests using `devtools::test()`:

```{verbatim}
#| eval: false
#| code-fold: false 
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols [0.1s]   
âœ” |        25 | check_binary_vec [0.2s]    
âœ” |        16 | check_facet_vec            
âœ” |         1 | pull_facet_cols           
âœ” |        16 | select_by_class [0.2s]       
âœ” |         5 | make_binary_vec            
âœ” |         7 | make_facet_vec             

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 0.7 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 71 ]
```

### Additional `pull_[type]_cols()` functions

My initial intention was to create functions for multiple UI inputs, including  `pull_numeric_cols()` and `pull_cat_cols()`. These two functions will be easier to develop now that I have working (and tested) versions of `pull_binary_cols()` and `pull_facet_cols()`.

#### Numerical columns tests 

`pull_cols_test` can be used to test `pull_numeric_cols()`--the `expected` values from `pull_numeric_cols()` includes the non-binary and non-facet double and integer columns:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_numeric_cols() test
testthat::test_that("pull_numeric_cols() works", {
  pull_cols_test <- readRDS(testthat::test_path("fixtures", "pull_cols_test.rds"))
  # test numeric columns
  testthat::expect_equal(object = pull_numeric_cols(pull_cols_test),
    expected =
      c(dbl_var_na = "dbl_var_na",
        dbl_var = "dbl_var",
        int_var_na = "int_var_na",
        int_var = "int_var")
    )
})
```

#### Categorical columns test

The test for `pull_cat_cols()` is similar--but the `expected` values are changed to non-binary and non-facet character, factor, and ordinal columns from `pull_cols_test`:

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_cat_cols() test
testthat::test_that("pull_cat_cols() works", {
  pull_cols_test <- readRDS(testthat::test_path("fixtures", "pull_cols_test.rds"))
  testthat::expect_equal(object = pull_cat_cols(pull_cols_test),
    expected =
      c(chr6_var = "chr6_var",
        chr7_var_na = "chr7_var_na",
        fct6_var_na = "fct6_var_na",
        fct7_var = "fct7_var",
        ord6_var_na = "ord6_var_na",
        ord7_var = "ord7_var")
    )
})
```

With these two tests written, I can move onto the functions. 

#### Write pull_numeric_cols()

In `pull_numeric_cols()`, `pull_binary_cols()` and `pull_facet_cols()` can identify the binary and facet columns. The outputs are combined  with `purrr::compact()` and `purrr::list_c()` into a named vector (`bins_facets`). 

For the numeric columns, `select_by_class()` will return the double and integer columns and combine them into `dbls_ints` (using the same methods as `bins_facets`)

The final (important) step involves removing `bin_facets` from `dbls_ints` using the [`%nin%`](https://github.com/mjfrigaard/utap/blob/5f1c408d41fa89cd87533d0eb93bbbd247b664cc/R/utils.R#L8) function.  

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_numeric_cols()
pull_numeric_cols <- function(df) {
    bins <- pull_binary_cols(df = df)
    facets <- pull_facet_cols(df = df)
    # assemble
    all_bins_facets_list <- list(bins, facets)
    # reduce
    bins_facets_list <- purrr::compact(all_bins_facets_list)
    # vector
    bins_facets <- purrr::list_c(bins_facets_list)
    # vector of doubles
    dbls <- select_by_class(df = df, type = 'dbl', return_tbl = FALSE)
    # vector of integers
    ints <- select_by_class(df = df, type = 'int', return_tbl = FALSE)
    # assemble
    all_dbls_ints_list <- list(dbls, ints)
    # reduce
    dbls_ints_list <- purrr::compact(all_dbls_ints_list)
    # vector
    dbls_ints <- purrr::list_c(dbls_ints_list)
    # reduce
    nums_nms <- dbls_ints[dbls_ints %nin% bins_facets]
    # name
    nums <- purrr::set_names(nums_nms)
    return(nums)
}
```

#### Write pull_cat_cols()

`pull_cat_cols()` is almost identical to `pull_numeric_cols()`, but uses `select_by_class()` to get the character and factor columns from the input data. 

```{r}
#| eval: false
#| code-fold: show 
#| code-summary: pull_cat_cols()
pull_cat_cols <- function(df) {
  bins <- pull_binary_cols(df = df)
  facets <- pull_facet_cols(df = df)
  # assemble
  all_bins_facets_list <- list(bins, facets)
  # reduce
  bins_facets_list <- purrr::compact(all_bins_facets_list)
  # vector
  bins_facets <- purrr::list_c(bins_facets_list)
  # remove these
  # characters
  chrs <- select_by_class(df = df, type = 'chr', return_tbl = FALSE)
  # factors
  fcts <- select_by_class(df = df, type = 'fct', return_tbl = FALSE)
  # assemble
  all_chrs_fcts_list <- list(chrs, fcts)
  # reduce
  chrs_fcts_list <- purrr::compact(all_chrs_fcts_list)
  # vector
  chrs_fcts <- purrr::list_c(chrs_fcts_list)
  # reduce
  cats_nms <- chrs_fcts[chrs_fcts %nin% bins_facets]
  # name
  cats <- purrr::set_names(cats_nms)
  return(cats)
}
```

#### Run additional `pull_[type]_cols()` tests

I'll run `devtools::test()` a final time to see if these new tests & functions pass: 

```{verbatim}
==> devtools::test()

â„¹ Testing utap
âœ” | F W S  OK | Context
âœ” |         1 | pull_binary_cols [0.2s]      
âœ” |         1 | pull_cat_cols [0.1s]         
âœ” |        25 | check_binary_vec [0.2s]       
âœ” |        16 | check_facet_vec [0.1s]        
âœ” |         1 | pull_facet_cols              
âœ” |        16 | select_by_class [0.2s]          
âœ” |         5 | make_binary_vec   
âœ” |         7 | make_facet_vec  
âœ” |         1 | pull_numeric_cols

â•â• Results â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Duration: 1.2 s

[ FAIL 0 | WARN 0 | SKIP 0 | PASS 73 ]

You are a coding rockstar!
```

## Verify with demo

I'm confident the `pull_[type]_cols()` functions are working, but I should confirm that they'll work from within a shiny app. I can do this with a demo application ([here is a great write-up](https://emilyriederer.netlify.app/post/shiny-modules/) on using demo apps).

### Demo UI

I'll create a simple UI with `fluidPage()`, and add four `selectInput()`s: 
-   Two will contain calls to `pull_numeric_cols()` (for the `x` and `y` inputs) 

-   The `color` input will use the `pull_binary_cols()` function

-   The fourth `selectInput()` will contain the `facet` input and call `pull_facet_cols()`

In the `mainPanel()`, I add `verbatimTextOutput()` to verify the columns from the `data` argument.

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'expand to see UI with pull_[type]_cols'
  # ui
  ui <- shiny::fluidPage(
    shiny::sidebarLayout(
      shiny::sidebarPanel(
        shiny::selectInput(
          inputId = "x",
          label = "X variable",
          choices = c(
            pull_numeric_cols(df = app_data)
          ),
          selected = pull_numeric_cols(df = app_data)[1]
        ),
        shiny::selectInput(
          inputId = "y",
          label = "Y variable:",
          choices = pull_numeric_cols(df = app_data),
          selected = pull_numeric_cols(df = app_data)[2]
        ),
        shiny::selectInput(
          inputId = "color",
          label = "Color variable:",
          choices = pull_binary_cols(df = app_data),
          selected = pull_binary_cols(df = app_data)[1]
        ),
        shiny::selectInput(
          inputId = "facet",
          label = "Facet variable:",
          choices = pull_facet_cols(df = app_data),
          selected = pull_facet_cols(df = app_data)[1]
        )
      ),
      shiny::mainPanel(
        h3("Testing app inputs"),
        shiny::br(),
        shiny::verbatimTextOutput(outputId = "selected")
      )
    )
  )
```

### Demo server

I don't need anything complicated in the server--just something to render the `selected` columns from the `app_data`. I'll use `renderPrint()` with `skimr::skim()` (because it will tell me useful information about the `selected` columns):

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'expand to see server with pull_[type]_cols'
# server
server <- function(input, output, session) {
  
  cols <- shiny::reactive({
    # combine in list
    all_cols_list <- list(
      x =  input$x, 
      y = input$y, 
      color = input$color, 
      facet = input$facet)
    # remove any null values 
    cols_list <- purrr::compact(all_cols_list)
    # convert to vector
    cols <- purrr::list_c(cols_list)
    return(cols)
    
  })

  output$selected <- shiny::renderPrint({
      selected_df <- dplyr::select(
        app_data,
        dplyr::any_of( cols() ))
        # view with skimr
        skimr::skim(selected_df) 
      }) |> 
        shiny::bindEvent(c(input$x, input$y,
                           input$color, input$facet))
}
```

### Demo app

Finally, I'll wrap the both the `ui` and the `server`  in the `demoInputsApp()` function and include a `data` argument (and a call to `shiny::shinyApp()`):

```{r}
#| eval: false
#| code-fold: true
#| code-summary: 'expand to see demoInputsApp()'
library(shiny)
library(NHANES)
library(utap)
library(skimr)

demoInputsApp <- function(data) {
  # data
  app_data <- data
  # ui
  ui <- shiny::fluidPage(
    shiny::sidebarLayout(
      shiny::sidebarPanel(
        shiny::selectInput(
          inputId = "x",
          label = "X variable",
          choices = c(
            pull_numeric_cols(df = app_data)
          ),
          selected = pull_numeric_cols(df = app_data)[1]
        ),
        shiny::selectInput(
          inputId = "y",
          label = "Y variable:",
          choices = pull_numeric_cols(df = app_data),
          selected = pull_numeric_cols(df = app_data)[2]
        ),
        shiny::selectInput(
          inputId = "color",
          label = "Color variable:",
          choices = pull_binary_cols(df = app_data),
          selected = pull_binary_cols(df = app_data)[1]
        ),
        shiny::selectInput(
          inputId = "facet",
          label = "Facet variable:",
          choices = pull_facet_cols(df = app_data),
          selected = pull_facet_cols(df = app_data)[1]
        )
      ),
      shiny::mainPanel(
        h3("Testing app inputs"),
        shiny::br(),
        shiny::verbatimTextOutput(outputId = "selected")
      )
    )
  )
  # server
  server <- function(input, output, session) {
    
    cols <- shiny::reactive({
      # combine in list
      all_cols_list <- list(
        x =  input$x, 
        y = input$y, 
        color = input$color, 
        facet = input$facet)
      # remove any null values 
      cols_list <- purrr::compact(all_cols_list)
      # convert to vector
      cols <- purrr::list_c(cols_list)
      return(cols)
      
    })
  
    output$selected <- shiny::renderPrint({
        selected_df <- dplyr::select(
          app_data,
          dplyr::any_of( cols() ))
          # view with skimr
          skimr::skim(selected_df) 
        }) |> 
              shiny::bindEvent(c(input$x, input$y,
                               input$color, input$facet))
  }
  # run
  shiny::shinyApp(ui = ui, server = server)
}
```

### Run demo

After running `devtools::load_all()` and `devtools::document()`, and rebuilding/installing `utap`, I can run the `demoInputsApp()` in the **Console** (be sure to supply the `NHANES` dataset).

```{r}
#| eval: false
#| code-fold: false
demoInputsApp(data = NHANES::NHANES)
```

:::: {.column-page-inset-right}
::: {#fig-demoInputsApp layout-nrow=1}

![demoInputsApp()](demoInputsApp.png){#fig-demoInputsApp width=100%}

`demoInputsApp()` demo app
:::
::::

I can verify the two numeric columns (`Poverty` and `Weight`) in the `x` and `y` inputs. 

:::: {.column-page-inset-right}
::: {#fig-verify_numeric layout-nrow=1}

![numeric inputs](verify_numeric.png){#fig-verify_numeric width=100%}

`demoInputsApp()` numeric app inputs
:::
::::

The `pull_binary_cols()` function is returning `SurveyYr`, which has 2 unique responses (see `n_unique`): 

:::: {.column-page-inset-right}
::: {#fig-verify_binary layout-nrow=1}

![binary inputs](verify_binary.png){#fig-verify_binary width=100%}

`demoInputsApp()` binary app inputs
:::
::::

Finally, I can see the `pull_facet_cols()` is correctly identifying `Race1` (a 5-level factor variable). 

:::: {.column-page-inset-right}
::: {#fig-verify_facets layout-nrow=1}

![facet inputs](verify_facets.png){#fig-verify_facets  width=100%}

`demoInputsApp()` facet app inputs
:::
::::

## Recap

This post covered unit tests for a set of shiny utility functions. I found using the [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development?oldformat=true) model (i.e., writing tests first) resulted in writing more thoughtful function code, and it likely reduced the amount of failed attempts for each function. My typical workflow has been developing functions and unit tests together, but writing a complete set of tests caused me to, '*begin with an end in sight*,' and gave me a solid understanding of each function's purpose.

### Review of unit tests & functions 

The `R/` folder now contains the following functions (accompanied by their unit tests in the `tests/testthat/` folder: 

1. `select_by_class.R`: contains `select_column_class()` and it's wrapper, `select_by_class()` for identifying column types from an input `data.frame`/`tibble`

    ```{verbatim}
    R/
     â””â”€â”€ select_by_class.R
         - select_column_class()
         - select_by_class()
 
    tests/testthat/
     â””â”€â”€ test-select_by_class.R
    ```
    
    a. `select_column_class()` returns tibble of columns by `type` (i.e., logical, integer, double, character, factor, etc.)
    b. `select_by_class()` returns either a `tibble` (`return_tbl = TRUE`) or a named vector (`return_tbl = FALSE`) of columns by `type`

2. `check_input_vectors.R`:  contains `check_binary_vec()` and `check_facet_vec()`, which are wrappers around the individual `check_` functions identifying each column type. 
        
    ```{verbatim}
    R/
     â””â”€â”€ check_input_vectors.R
         - check_binary_vec()
           - check_log_binary()
           - check_int_binary()
           - check_chr_binary()
           - check_fct_binary()
         - check_facet_vec()
           - check_chr_facet()
           - check_fct_facet()
    tests/testthat/
     â”œâ”€â”€  test-check_binary_vec.R
     â””â”€â”€  test-check_facet_vec.R
    ```
    
    a. `check_binary_vec()` identifies binary columns (having <= 2 unique values): 
        i. `check_log_binary()`, `check_int_binary()`, `check_chr_binary()`, `check_fct_binary()`  
    b. `check_facet_vec()` identifies facet columns (having <= 5 unique values):    
        i. `check_chr_facet()` and `check_fct_facet()`

3. `make_input_vectors.R`: iterates the `check_` functions over the columns returned from the `select_by_class()` function

    ```{verbatim}
    R/
     â””â”€â”€  make_input_vectors.R
          - make_binary_vec()
          - make_facet_vec()
    tests/testthat/
     â”œâ”€â”€ test-make_binary_vec.R
     â””â”€â”€ test-make_facet_vec.R
    ```
    
    a. `make_binary_vec()` creates a named vector of binary columns
    
    b. `make_facet_vec()` create a named vector of facet columns 

4. `pull_cols.R`: contains the four `pull_[type]_cols` functions

    ```{verbatim}
    R/
     â””â”€â”€ pull_cols.R
         - pull_binary_cols() 
         - pull_facet_cols()
         - pull_numeric_cols()
         - pull_cat_cols()
    tests/testthat/
     â”œâ”€â”€ test-pull_binary_cols.R
     â”œâ”€â”€ test-pull_facet_cols.R
     â”œâ”€â”€ test-pull_numeric_cols.R
     â””â”€â”€ test-pull_cat_cols.R
    ```
    
    a. `pull_binary_cols()` returns binary columns from an input `data.frame`/`tibble`   
    b. `pull_facet_cols()` returns facet columns from an input `data.frame`/`tibble`  
    c. `pull_numeric_cols()` returns non-binary numerical columns (double/integer) from an input `data.frame`/`tibble`  
    d. `pull_cat_cols()` returns non-binary/non-facet categorical columns from and input `data.frame`/`tibble`  
    
The following files in the `R/` folder weren't tested, but serve other important functions:

5. `utap-package.R`: is used for documenting add-on packages and functions in the `NAMESPACE`

    ```{verbatim}
    R/
     â””â”€â”€ utap-package.R
         - 'used for documenting namespace'
    ```
    
    -   Read more about the [`usethis::use_package_doc()` function](https://r-pkgs.org/man.html#sec-man-package-doc)

6. `utils.R`: holds smaller functions that don't belong in any particular file 

    ```{verbatim}
    R/
     â””â”€â”€ utils.R
         - `%nin%`
    ```
    
    - The `%nin%` function is used in `select_by_class()`, `pull_facet_cols()`, and `pull_numeric_cols()`.
    
***...confirming your tests...***

After all the unit tests passed, I made sure they were generating the desired output in a small demo app. In the next post, I'll cover testing shiny server functions using `shiny::testServer()`.
    
7. `demoInputsApp.R` contains the code for running the demo UI inputs app     
    
    ```{verbatim}
    R/
     â””â”€â”€ demoInputsApp.R
         - demoInputsApp() 
    ```
    
    a. `demoInputsApp()` will create a demo shiny application with when data is supplied to the `data` argument

***..on data...***

If you're going to need specific test data in your app, store these in `tests/testthat/<directory>/`. Any additional functions required for testing should be stored in a `helpers.R` file. The benefits of using helper functions to generate for testing are 1) control over the  data you're testing, and 2) separating test data from any other data in your package.

`tests/testthat/helpers.R` contains the code for the test data and the test data files. 

-   The test data (`.rds`) and code (`make_<data>.R`) are stored in `tests/testthat/fixtures/`:

    ```{verbatim}
    tests/testthat/fixtures/
      â”œâ”€â”€ pull_cols_test.rds
      â”œâ”€â”€ binary_vec_test.rds
      â”œâ”€â”€ col_types_test.rds
      â”œâ”€â”€ facet_vec_test.rds
      â”œâ”€â”€ make_pull_cols_test.R
      â”œâ”€â”€ make_binary_vec_test.R
      â”œâ”€â”€ make_col_types_test.R
      â””â”€â”€ make_facet_vec_test.R
    
    1 directory, 8 files
    ```
    
### More resources 


For a more comprehensive review of testing, check out the chapters on testing in [R packages](https://r-pkgs.org/testing-basics.html) and [Mastering Shiny](https://mastering-shiny.org/scaling-testing.html).


